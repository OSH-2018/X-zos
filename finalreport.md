# Unikernel Monitor 项目总结报告

## 项目背景

Unikernel为了实现体量的缩小，选择了与Docker完全不同的路线。它只专注于一个目标程序，而没有其它冗余的程序和支持，包括操作系统的进程管理，异常处理与日志报告等等，没有多进程切换，所以系统很小也很简单。而正因为此，很多原有的功能都被取消掉，这使得传统的调试手段：  

1. 在开发过程中使用GDB进行追踪
2. 在发行阶段采用日志系统查看程序的运行状态 
3. 依赖操作系统的报错信息，内核转储信息等等机制实现错误的重现并修复　　　

变得极其困难。具体来讲，以下常用的调试技术变得不再可行：　　

**编程过程中将信息输出在控制台或者文件中**  

在实际运行Unikernel的时候是不会模拟显示器的，所以无法将调试信息输出到控制台。又因为Unikernal的文件系统做了很大的精简，没有VFS，而且不同Unikernal的文件系统设计也不完全一样,所以，我们如果将日志写入文件，就很难再将虚拟磁盘中的东西读出来。　　

**通过与其他进程通信来进行追踪和调试**　  
 
Unikernel为了实现精简，而放弃了原有的很多功能，其中就包括多进程切换。没有了多进程，就无法利用与其他进程通信来进行debug。　　

Unikernel的程序运行方式决定了它很难像普通的应用程序一样调试，但这并不代表Unikernel完全不可调试。事实上，经过了许多尝试后，我们发现：  

*通过**用户态协议栈**来对Unikernel进行网络通信，可以很好地将调试信息取出并实现对程序的监控。*　  

这也是Umonitor的主要思想。

## 项目概述

### Umonitor是什么？

Umonitor是一种针对Unikernel的调试工具，旨在在没有传统debug环境的支持下改善Unikernel的调试环境。在保留Unikernel现有优势的基础之上，减少其劣势对开发者使用的影响。　
　　
### Umonitor做了什么？　　

Umonitor利用用户态协议栈建立了host与Unikernel之间的网络通信，从而实现了对Unikernel程序的监控。　　

具体而言，Umonitor实现了：　　

* 批量接收、查看、管理Unikernel程序运行日志
* 在host端以文件的形式保存调试信息
* 多Unikernel同时监控
* 命令行交互

## 项目功能

通常的网络云计算要求服务程序多并发长时间不宕机地运行，所以比起通常的断点方式--可能造成的时间成本和效率影响是不可接受的，获得服务程序的运行日志是更为行之有效的维护调试方式，对于常被应用于这个方面的Unikernel来说更是如此。项目中提出并实现的Umonitor，就是一个旨在令Unikernel实际运行时，运维人员对Unikernel的调试和维护工作变得更为轻松有效的解决方案。

Umonitor是一个利用系统自带的虚拟网卡，通过socket和多线程并发收发调试信息的日志式调试系统。用户在使用时只需在每个需要调试的Unikernel里调用工具中的send_log()函数，将想要得到的调试信息传入函数，然后在主机的环境里面启动一个host端，host端就能通过虚拟网卡接口接收到来自不同Unikernel的调试信息并整理保存。

我们认为，这套工具的优势主要在以下方面：

并发性：只需启动一个host端就能服务复数的Unikernel而无需多开，提高了效率

兼容性：避开了不同的Unikernel的差异性，如使用的语言，内存空间，文件系统等的不同，选择了它们的共性，对socket的支持作为实现方法，几乎所有的Unikernel都能无难度地移植这个调试系统

高度可控可定制化：首先直接在运行Unikernel的虚拟机的模拟vga输出界面打印调试信息会造成很大的切换和检索的麻烦，而重定向vga输出信息至某个文件似乎是相对更好的方法，但仍然有着不能完全自定义日志内容的缺点，会输出非常多Unikernel自带对调试无用或者不够清晰的信息，不能得到一个组织良好的日志文件，另外多个Unikernel并发重定向在某些情况下可能造成输出混杂，不能正确地输出文件（？）。利用socket传递自己想要的调试信息并组织保存，能够生成用户自己最需要的最有用的日志文件，提高调试的效率

## 功能实现

umonitor的功能主要是建立unikernel与host之间的连接，并接收unikernel发来的日志信息。考虑到实际环境中的使用需要，我们实现了批量监控unikernel的功能。

### 建立虚拟硬件接口

在host方面，建立TAP网卡的过程我们放弃了在程序中自己实现，而是采用了调用bash的IP命令实现。

 ip tuntap { add | del } [ dev PHYS_DEV ] \
    [ mode { tun | tap } ] [ user USER ] [ group GROUP ] \
    [ one_queue ] [ pi ] [ vnet_hdr ]

这样也方便进行权限管理相关的其他扩展内容。

而在unikernel一方，要想实现通信，也需要有tap虚拟设备支持，好在KVM/qemu支持使用TAP，只需要在启动过程中添加参数即可。

### 创建新的连接

既然已经准备好虚拟硬件和驱动，就可以实现一种和正常网络通信没有区别的信息传输了。在这里，我们采用传统的客户机-服务器模型，将unikernel部分作为客户机，host部分作为服务器，这样的设计是为了维护unikernel的服务中心地位，在一般的设计当中，unikernel都是作为服务器出现的，因此我们可以将host视作unikernel的服务对象之一，服务内容就是将unikernel的运行状态告知host。

这里我们考虑了实际应用中的场景：一般来说我们希望监视多个unikernel的运行状态，并且将各个unikernel的日志写到不同的文件中去，这样才符合人们的习惯。这就涉及到分配IP，分配端口，启动，连接的过程。

### 判断状态，发送与接收信息

对于每个负责接收的线程来说，都需要将接收的信息进行处理并写入到文件当中，这个过程对于unikernel来说是个黑箱，即为：Unikernel只负责将信息传输给host，但是host如何处理，并不关它的事。而且就算出现了错误，它也只负责将错误告知host，然后继续运行，即使这样的错误会导致unikernel的运行崩溃，这样设计的考虑主要还是因为简单有效，而并不需要区分很多不同类型的错误。

目前我们设计的接收到的日志消息分为3种：普通的日志（函数调用栈，参数名称和对应的值），警告日志（比如传入了NULL指针，发生了运算溢出），错误日志（发生了除0错误，或者访问NULL指针等）。这些信息可以让监视着对于unikernel的运行过程有更清楚的了解，在发现unikernel运行出现问题的时候通过日志可以完全恢复出其运行状态，从而方便地定位错误进行修复。

(引用一下demo里的演示程序。)

### 记录日志，必要的时候给出报错信息

(这里应该还需要加一些代码什么的。)

## 未来扩展

我们的umonitor已经可以在rumpkernel的平台上通过对unikernel源代码的修改，通过网络通信的方式将unikernel中我们想要的调试信息输出到制定文件中，初期制定目标已经达到，但是，要看到unikrnel这一概念在未来可能的广泛应用的话，对于调试方面显然还需要更加多样化，更方便的功能需求，因此，我们的项目仍然有很多发的空间。

首先，我们现在的实现仍然主要在rumprun的平台上，然而现在虽然unikernel仍处于一个非常早期的发展阶段，但是已经有诸如Clive，ClickOS，OSv，IncludeOs等较为
成熟的实现，且每一种实现都有其擅长的领域。如：ClickOS用于构建网络功能虚拟化;Clive用go语言编写，工作于分布式和云计算环境中;IncludeOS在云中运行C+服务等等。而在某些情况下，这些不同的unikernel实现甚至可能同时使用，并且需要调试。在这样的情况下，一个unikernel的调试工具必然需要提供一个通用的接口以实现对不同种类unikernel的支持。我们的umonitor已经实现了能同时对多个unikerlnel的调试，所以下一步的目标就应该是实现对多种unikernel的通用接口。使其够方便的支持现阶段较为成熟的unikernel实现的同时也能够通过用户友好的配置界面对其他unikernel进行支持。

然后，在umonitor的实现中，直接调用了TUN/TAP设备，方便地模拟了网络行为。所以如果能力允许的话，后续的工作也可能放在寻找性能更好的替代或者有能力的话自实现定制化的接口。

再进一步，我们的umonitor在运行之后实际上仍然只能被动地接受被调试的unikernel输出的调试信息，这样虽然能够在一次设置后找到对应的错误信息出现的位置，但想要在unikernel运行中途添加调试信息输出或者更进一步的设置断点和逐句执行都还做不到，虽然这些都属于一个完整的调试工具所必须的功能，但是由于实现非常复而且所需知识已经超出现在所学且考虑到时间问题，所以暂时无法完整实现，而当在后面的学习中如果掌握了所需知识，交互式的调试也将会是一个主要的开发方向。

考虑到很多需要通过在源代码中添加调试输出语句输出的信息，都是具有一定特征的，比如在每个函数调用时可能会需要提供栈，传入变量等信息，要求程序员在调试的候手动在每个函数的开头处添加调试信息输出语句显然是不现实的，这也会对程序员造成很大的扎负担（说白了这样非常不友好）。所以，考虑在编译前对代码进行自动的预处理。这一点，已经对c语言进行了一定程度上的实现，但是如果在C++语言中，由于类，重载等语法，实现起来是非常复杂的。对多种编程语言的支持也成为一个重的功能。同时，根据具体调试目的的不同，需要的调试信息类型也不尽相同，提供图形化的调试选项界面也是一个提高使用体验的关键点。

综合看起来，我们的umonitor工程只是在改善unikernel调试的路上开了一个头，可以说先是实现了一个概念性的框架，后续还有很多可以做的工作。

## 小组分工

本次大作业的小组分工以各个同学了解擅长的内容按优先级划分，主要为了让组内成员得以做自己最为擅长的工作。

### 写作任务

写作任务主要涉及到本项目的立项依据，可行性分析和发展规划。括号中为相关内容的贡献者。

立项依据也就是我们做的调研报告部分，主要分析了云计算行业的发展现状和面临的挑战(冉礼豪)，容器化技术、Unikernel的出现和主要思想分析，unikernel与docker的比较（任正行），Unikernel的优点和局限性，使用场景（管修贤），目前的几个主流unikernel项目调研分析（胡煜霄），Unikernel的未来发展前景（戈惊宇）。

可行性分析也就是我们在可行性报告中的内容，主要论证了这个项目的可行性，包括unikernel本身的重要性（管修贤），和unikernel本身面临的局限即调试问题，其中我们分析了一个应用调试的原理，参照传统的调试方法，结合实际应用的过程中的场景，给出一个大致的实现方案（任正行），于是论证了给unikernel添加调试接口的可行性。

### 实验与编码任务

对于实验部分，由于实现的方案选择很多，包括文件I/O，串口通信，网络通信等，我们主要对这3个方案进行了实验，其中文件I/O实验由冉礼豪同学完成，串口通信方案和网络通信方案由任正行完成实验，最终由于使用网络进行通信更加方便实现和扩展，最终选择了通过网络完成unikernel向host发送日志信息的过程。

### 资料的收集整理任务

由于unikernel的发展还不是很完善，相关的产品比较繁杂，所以资料收集起来比较麻烦，本次主要收集资料的来源于wikipedia, unikernel.org, ibm的各种技术博客，官方的介绍书籍等等。

## 收获与教训

1. 关于调研与立项：理想与现实的矛盾就是机遇。一开始，我们并没有任何的指导方向，只是随便调研一些东西，也没有明确的方向什么的，一开始的课题还被否定了，最终顺利定题的关键就在于我们找到了理想与现实的矛盾之处：unikernel很快很小很安全，却还没有得到大范围的应用，原因是什么？跟着这个问题，我们发现了unikernel难以调试和监控的事实，这就是unikernel大范围应用的其中一个阻碍。
2. 关于报告的书写：内容的逻辑性比内容的丰富程度要重要。在书写调研报告和可行性报告的过程中，我们以为找到了大量的资料之后，就可以按照资料进行搬运翻译的工作，就可以拼凑成一个好的报告了，最终实施的时候发现远比我们想象的复杂，一份好的报告应该是思路清晰，排版合理，内容精炼但容易读懂的。我们关于这个项目的所有想法和理由，都要通过一个合理的逻辑环展示在报告中，否则很难说服别人这个项目有价值并且可行的。在现实中，一份好的报告甚至决定着工作是否能被别人认可，所以关于写作的技术我们还需要加强。
3. 关于实现方案：从实现难度和实用程度两个角度考虑，结合时间选择最合适的方案。我们一开始有很多想法看似可以实现最终的目标，但是其中有一些简单而没有实用性，有一些听起来很好用但是实际实现起来需要很多功夫。我们一开始犯了错误就是从看起来最美好但是实现也最难的方案入手，但是最终因为组员的技术有限，时间有限，无法实施，而且浪费了很多时间。我们在被放弃的方案上折腾了超过1个月，最终被迫选择比较简单的方案，但是最终以我的使用经验，这样简单的方案最终也取得了很好的效果，如果当初我们从较为简单也比较实用的方案入手，我们可能很快就能摆脱大作业的压力了。
4. 关于小组成员的合作：各个成员之间的信息要共享，透明，减少组员的学习代价。一开始，因为unikernel对我们来说都是新的东西，都需要折腾一番，因为我（任正行）比较能肝也有相关工具的实用经验，所以先摸清楚了几个unikernel项目的状况和使用方法，但是我没有及时将这些信息共享给组员，这样其实我的优势对于全组的进度并没有带来什么好处，后期我及时将自己所掌握的所有信息分享给其他组员，减少了其他组员的学习代价，加快了我们这个项目的进度。
5. 最终演示阶段：要面向用户展示详细的使用方法。在演示的过程当中，我（任正行）发现表达出来的信息并没有准确地理解，原因在于展示过程中，我应该说清楚对于一个用户来说，需要做怎样的工作实现对unikernel的监视，并且还需要做前后的对比，达到一个突出自己项目价值的目的。

## 参考资料 & 致谢

[rumpkernel wiki](https://github.com/rumpkernel/wiki/wiki) \
[clive lsub manual](http://lsub.org/sys/man/) \
[rumprun network config](https://github.com/rumpkernel/wiki/wiki/Howto%3A-Configuring-a-802.11-device) \
[rumprun if_virt](https://github.com/rumpkernel/wiki/wiki/Howto%3A-Networking-with-if_virt) \
[rumpkernel and anykernel book](http://www.fixup.fi/misc/rumpkernel-book/) \
[rumpkernel build packages](https://github.com/rumpkernel/wiki/wiki/Builds%3A-Binary-packages) \
[rumprun kernel development](https://github.com/rumpkernel/wiki/wiki/Tutorial%3A-Kernel-development) \
[rumprun server example](https://github.com/rumpkernel/wiki/wiki/Tutorial%3A-Serve-a-static-website-as-a-Unikernel)

感谢老师和助教的帮助和引导，这堂课提供的平台让我们在很多方面取得了很大的收益！感谢Unikernel社区开发者的解答！